<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2015 | Lets Dive!</title>
  <meta name="author" content="Lukas Pukenis">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Lets Dive!"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Lets Dive!" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Lets Dive!</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2015</h2>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-08-16T07:39:21.000Z"><a href="/2015/08/16/c++-trimming/">Aug 16 2015</a></time>
      
      
  
    <h1 class="title"><a href="/2015/08/16/c++-trimming/">C++ Trimming</a></h1>
  

    </header>
    <div class="entry">
      
        <p>I wanted to write <code>trim</code> functionality and was amazed how elegant it can be in c++ with standard library calls and iterators. The idea is simple - construct a new container by passing begin and end iterators. For the begin iterator we can find it with <code>std::find_if_not</code> and for the end iterator its the same but we need to use revered iterators <code>rbegin</code> and <code>rend</code>. Note that there’s a difference between iterators. It doesnt make sense to mix forward and reverse iterators. To convert reverse iterator into a forward one use <code>base</code> method on iterator.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;iterator&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="preprocessor">#include &lt;cctype&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
T trim(T <span class="keyword">const</span> & str) {
  <span class="keyword">return</span> T(
    <span class="built_in">std</span>::find_if_not(str.begin(), str.end(), <span class="built_in">std</span>::<span class="built_in">isspace</span>),
    <span class="built_in">std</span>::find_if_not(str.rbegin(), str.rend(), <span class="built_in">std</span>::<span class="built_in">isspace</span>).base()
  );
}
</pre></td></tr></table></figure>

<p>And it works on generic types that provide iterators. This is a generic solution but doesn’t make sense on other types than strings and char data data because <code>std::isspace</code> is hardcoded. We could generify this solution to accept the checker so we could trim for example a <code>std::vector&lt;int&gt;</code>.</p>
<p>First lets define <code>&lt;&lt;</code> operator for <code>std::vector&lt;int&gt;</code> so we could easily print it with <code>std::cout</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="built_in">std</span>::ostream & <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">std</span>::ostream& os, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> &v) {
  <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> i : v) {
    os &lt;&lt; i &lt;&lt; <span class="string">"  "</span>;
  }
  <span class="keyword">return</span> os;
}
</pre></td></tr></table></figure><br>Now we can launch<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> v = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};
<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v;
</pre></td></tr></table></figure><br>and it prints <code>1 2 3</code>. Lets move the checker function into a template argument because it may be a <code>std::function</code> or a functor, I just want to know I can call <code>operator()</code> on it.<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>template &lt;typename T, typename C&gt;
T trim(T <span class="keyword">const</span> & <span class="keyword">str</span>, C <span class="keyword">check</span>) {
  <span class="keyword">return</span> T(
    std::find_if_not(<span class="keyword">str</span>.begin(), <span class="keyword">str</span>.end(), <span class="keyword">check</span>),
    std::find_if_not(<span class="keyword">str</span>.rbegin(), <span class="keyword">str</span>.rend(), <span class="keyword">check</span>).base()
    );
}
</pre></td></tr></table></figure><br>and now do partial specialization without checker function(providing default <code>std::isspace</code> check)<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
T trim(T <span class="keyword">const</span> & str) {
  <span class="keyword">return</span> T(
    <span class="built_in">std</span>::find_if_not(str.begin(), str.end(), <span class="built_in">std</span>::<span class="built_in">isspace</span>),
    <span class="built_in">std</span>::find_if_not(str.rbegin(), str.rend(), <span class="built_in">std</span>::<span class="built_in">isspace</span>).base()
    );
}
</pre></td></tr></table></figure>

<p>And its test time</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">auto</span> a = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"hello   "</span>);
<span class="keyword">auto</span> b = <span class="built_in">std</span>::<span class="built_in">string</span> (<span class="string">"hello   "</span>);
<span class="keyword">auto</span> c = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"    hello   "</span>);

<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; trim(a) &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::endl;
<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; trim(b) &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::endl;
<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; trim(c) &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::endl;
</pre></td></tr></table></figure><br>Results are<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>[hello]
[hello]
[hello]
</pre></td></tr></table></figure><br>And now its vector time. Lets trim out the multipliers of 10<br><br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">bool</span> testPowerOf10(<span class="keyword">int</span> n) {
  <span class="keyword">return</span> n % <span class="number">10</span> == <span class="number">0</span>;
}

<span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> d = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>};
<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"notrim ["</span> &lt;&lt; trim(d) &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::endl;
<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"trim   ["</span> &lt;&lt; trim(d, testPowerOf10) &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::endl;
</pre></td></tr></table></figure><br>the results are<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="tag">notrim</span> <span class="attr_selector">[0  1  2  3  4  5  6  7  8  ]</span>
<span class="tag">trim</span>   <span class="attr_selector">[1  2  3  4  5  6  7  8  9  ]</span>
</pre></td></tr></table></figure>

<p>To be fully satisfied I should do left and right trims as current trim works on both sides and sometimes we need only one. Left trim should contain very minimal changes</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C&gt;
T ltrim(T <span class="keyword">const</span> & str, C check = <span class="built_in">std</span>::<span class="built_in">isspace</span>) {
  <span class="keyword">return</span> T(
    <span class="built_in">std</span>::find_if_not(str.begin(), str.end(), check),
    str.end()
    );
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
T ltrim(T <span class="keyword">const</span> & str) {
  <span class="keyword">return</span> T(
    <span class="built_in">std</span>::find_if_not(str.begin(), str.end(), <span class="built_in">std</span>::<span class="built_in">isspace</span>),
    str.end()
    );
}
</pre></td></tr></table></figure><br>the difference is that I removed the reverse check. And for <code>rtrim</code> it should look like this<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>T <span class="function">rtrim(T const & str, C check = std::isspace)</span> {
  return <span class="function">T(
    str.<span class="function">begin()</span>,
    std::<span class="function">find_if_not(str.<span class="function">rbegin()</span>, str.<span class="function">rend()</span>, std::isspace)</span>.<span class="function">base()</span>+<span class="number">1</span>
    )</span>;
}

template &lt;typename T&gt;
T <span class="function">rtrim(T const & str)</span> {
  return <span class="function">T(
    str.<span class="function">begin()</span>,
    std::<span class="function">find_if_not(str.<span class="function">rbegin()</span>, str.<span class="function">rend()</span>, std::isspace)</span>.<span class="function">base()</span>
    )</span>;
}
</pre></td></tr></table></figure><br>Note that trim functions with <code>std::vector&lt;int&gt;</code> or other non-string data without proper checker function may behave strange like this:<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> d = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>};
<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"notrim ["</span> &lt;&lt; rtrim(d) &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::endl;
<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"trim   ["</span> &lt;&lt; rtrim(d, testPowerOf10) &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::endl;
</pre></td></tr></table></figure>

<p>It will produce</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="tag">notrim</span> <span class="attr_selector">[0  1  2  3  4  5  6  7  8  ]</span>
<span class="tag">trim</span>   <span class="attr_selector">[0  1  2  3  4  5  6  7  8  9  ]</span>
</pre></td></tr></table></figure><br>it is so because <a href="http://en.cppreference.com/w/cpp/string/byte/isspace" target="_blank" rel="external">std::isspace</a> filters out line feed<em>(0x0a)</em> and horizontal tab<em>(0x09)</em> values so it doesnt make sense to use on non char data.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-08-10T17:44:23.000Z"><a href="/2015/08/10/Sudoku-Solver/">Aug 10 2015</a></time>
      
      
  
    <h1 class="title"><a href="/2015/08/10/Sudoku-Solver/">Sudoku Solver</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Sudoku is a simple puzzle, quite boring(personal opinion). It’s rules are very basic - only have numbers <strong>1</strong> to <strong>9</strong> appear once in the row and column and also in 3x3 by 3x3 block.</p>
<p>This is an example sudoku puzzle</p>
<img src="/images/sudoku/sudoku.png" class="[here]">

<p>This is an example of solved puzzle</p>
<img src="/images/sudoku/sudoku-solved.png" class="[]">

<p>Sudoku of course could be solved by applying bruteforce but we dont have that much of computational power. A better method would be to find an empty node and try to fill it in with a number from <em>1</em> to <em>9</em> then search for another empty node and insert a number which is valid there. This is an easy to implement method and our main loop will look something like this:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">solve</span>()</span>
  node = find_unassigned_node()
  <span class="keyword">for</span> i= <span class="number">1</span>, <span class="number">9</span> <span class="built_in">do</span>
    node.<span class="built_in">value</span> = i
    <span class="keyword">if</span> solve() <span class="keyword">then</span> <span class="constant">return</span> <span class="constant">true</span> <span class="function"><span class="keyword">end</span></span>
    node.<span class="built_in">value</span> = <span class="constant">EMPTY</span>
</pre></td></tr></table></figure>

<p>This pseudocode is actually correct <code>Lua</code> code but Lua has nothing to do in this article :). This is transcription of whats going on: “I will try placing 1 here because I can and then I will look for another empty node and will try to fit in what I can. In case I can’t fit any value I know I’ve failed somewhere”. After looping through all the values and not returning true we are very sure we have failed so <code>return false</code> should indicate that. <code>return true</code> of course should indicate success.</p>
<p>Now actual <code>C++</code> code for main loop look like this:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>bool solve() {
    /*
      we are sure puzzle is solved <span class="keyword">as</span> there are no more empty nodes
      <span class="keyword">and</span> that will not happen on failure because <span class="keyword">in</span> case <span class="keyword">of</span> something wrong
      the recursive algorithm will backtrack <span class="keyword">to</span> the point where mistake will be fixed
    */

    auto pos = getUnassignedPosition();
    <span class="keyword">if</span> (pos == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;

    <span class="comment">// we have 1..9 values to try. 0 is invalid value in Sudoku so we can use it to indicate empty node</span>
    <span class="keyword">for</span> (auto <span class="keyword">val</span> = <span class="number">1</span>; <span class="keyword">val</span> &lt; <span class="number">10</span>; <span class="keyword">val</span>++) {
      <span class="keyword">if</span> (isGood(pos, <span class="keyword">val</span>)) {
        puzzle[pos] = <span class="keyword">val</span>;
        <span class="keyword">if</span> (solve()) <span class="keyword">return</span> <span class="keyword">true</span>;
        puzzle[pos] = <span class="number">0</span>;
      }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
  }
</pre></td></tr></table></figure><br>Notice that <code>true</code> will be returned only when we can’t insert any more values anywhere meaning puzzle is full. At that point the recursion will loop back through the <code>if (solve()) return true;</code> in case <code>solve()</code> doesnt return <code>true</code> we reset the value thus “fixing” the mistake and trying another number and if all numbers fail we return false thus <code>puzzle[pos] = 0;</code> can revert back our mistake. If the puzzle is solvable then a node must accept at least one number so we will always have another call to <code>solve()</code> in case you were wondering that <code>return false;</code> will prematurely return from the search.<br><br><br>Method for finding unassigned positions is pretty trivial:<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">// returns -1 on failure</span>
<span class="keyword">int</span> getUnassignedPosition() {
    <span class="keyword">auto</span> idx = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &i : puzzle) {
      <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> idx;
      idx++;
    }
    <span class="keyword">return</span> -<span class="number">1</span>;
  }
</pre></td></tr></table></figure>

<p>And the main bits left are checking if slot is good for the value we want to insert, we need to check that vertical, horizontal, and blocks:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="built_in">bool</span> isGood(u_int x, u_int y, u_int val) {
    <span class="comment">// check horizontal</span>
    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {
      <span class="keyword">if</span> (puzzle[y * <span class="number">9</span> + i] == val) <span class="keyword">return</span> <span class="literal">false</span>;
    }
    
    <span class="comment">// check vertical</span>
    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {
      <span class="keyword">if</span> (puzzle[i * <span class="number">9</span> + x] == val) <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="comment">// check 3x3 block</span>
    <span class="keyword">auto</span> xBlockIndex = x / <span class="number">3</span>;
    <span class="keyword">auto</span> yBlockIndex = y / <span class="number">3</span>;

    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {
      <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) {
        <span class="keyword">auto</span> _x = xBlockIndex * <span class="number">3</span> + i;
        <span class="keyword">auto</span> _y = yBlockIndex * <span class="number">3</span> + j;
        <span class="keyword">if</span> (puzzle[_y * <span class="number">9</span> + _x] == val) <span class="keyword">return</span> <span class="literal">false</span>;
      }
    }

    <span class="keyword">return</span> <span class="literal">true</span>;
  }

  <span class="comment">// overload for flat position instead of x and y pair</span>
  <span class="built_in">bool</span> isGood(u_int flatPosition, u_int val) {
    <span class="keyword">return</span> isGood(flatPosition % <span class="number">9</span>, flatPosition / <span class="number">9</span>, val);
  }
</pre></td></tr></table></figure><br>And here we go, this thing solves sudoku quite fast. To be exact on i7-4770k it solves ~1587 puzzles in 1 second which is amazing by looking at what primitive and simple algorithm it is. It can be even faster while trading some memory for saving some meta information about the grid, for example updating what values can be inserted in this row or column or block.<br><br>Here’s full code:<br><figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
</pre></td><td class="code"><pre><span class="preprocessor">#include "stdafx.h"</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">struct</span> Sudoku {
  <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u_int;

  <span class="keyword">bool</span> isGood(u_int x, u_int y, u_int val) {    
    <span class="comment">// check horizontal</span>
    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {
      <span class="keyword">if</span> (puzzle[y * <span class="number">9</span> + i] == val) <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    
    <span class="comment">// check vertical</span>
    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {
      <span class="keyword">if</span> (puzzle[i * <span class="number">9</span> + x] == val) <span class="keyword">return</span> <span class="keyword">false</span>;
    }

    <span class="comment">// check 3x3 block</span>
    <span class="keyword">auto</span> xBlockIndex = x / <span class="number">3</span>;
    <span class="keyword">auto</span> yBlockIndex = y / <span class="number">3</span>;

    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {
      <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) {
        <span class="keyword">auto</span> _x = xBlockIndex * <span class="number">3</span> + i;
        <span class="keyword">auto</span> _y = yBlockIndex * <span class="number">3</span> + j;
        <span class="keyword">if</span> (puzzle[_y * <span class="number">9</span> + _x] == val) <span class="keyword">return</span> <span class="keyword">false</span>;
      }
    }

    <span class="keyword">return</span> <span class="keyword">true</span>;
  }

  <span class="keyword">bool</span> isGood(u_int flatPosition, u_int val) {
    <span class="keyword">return</span> isGood(flatPosition % <span class="number">9</span>, flatPosition / <span class="number">9</span>, val);
  }


  <span class="keyword">bool</span> solve() {
    <span class="keyword">auto</span> pos = getUnassignedPosition();
    <span class="keyword">if</span> (pos == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;

    <span class="keyword">for</span> (<span class="keyword">auto</span> val = <span class="number">1</span>; val &lt; <span class="number">10</span>; val++) {
      <span class="keyword">if</span> (isGood(pos, val)) {
        puzzle[pos] = val;
        <span class="keyword">if</span> (solve()) <span class="keyword">return</span> <span class="keyword">true</span>;
        puzzle[pos] = <span class="number">0</span>;
      }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>;
  }

  <span class="keyword">int</span> getUnassignedPosition() {
    <span class="keyword">auto</span> idx = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &i : puzzle) {
      <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> idx;
      idx++;
    }
    <span class="keyword">return</span> -<span class="number">1</span>;
  }

  <span class="keyword">void</span> solve(<span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> & _puzzle) {
    puzzle = _puzzle;

    solve();
    print();
  }

  <span class="keyword">void</span> print() {
    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0u</span>; i &lt; <span class="number">9</span>; i++) {
      <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0u</span>; j &lt; <span class="number">9</span>; j++) {
        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; puzzle[i * <span class="number">9</span> + j] &lt;&lt; <span class="string">" "</span>;
      }
      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;
    }
    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;
  }
<span class="keyword">private</span>:
  <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> puzzle;
};

<span class="keyword">int</span> main() {
  <span class="built_in">std</span>::<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> puzzle = {
    <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>,
    <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,
    <span class="number">0</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>,
    <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>,
    <span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>,
    <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>,
    <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>,
    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">4</span>,
    <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>
  };

  Sudoku sudoku;
  sudoku.solve(puzzle);

  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-02-16T18:19:50.000Z"><a href="/2015/02/16/day--or--night/">Feb 16 2015</a></time>
      
      
  
    <h1 class="title"><a href="/2015/02/16/day--or--night/">Day or Night</a></h1>
  

    </header>
    <div class="entry">
      
        <p>There was an interesting problem - to decide if given image is day or night. This is a problem on HackerRank and this solution should only be used as a reference because its more fun to solve those challenges yourself.</p>
<p>The input comes in as <code>r1, g1, b1 r2, g2, b2 r3, g3, b3 ...</code>. So the image decoding is handled for us. Given all the pixels how should we decide is the image day or night?</p>
<p>Calculating average <strong>RGB</strong> value provides nothing sensible as RGB is not linear with respect to lighting. To convert RGB to something what maps light linearly we have some choices like HSV or HSL. HSV Cylinder proves that lightness is quite linear</p>
<img src="/images/common/hsv_cylinder.png" class="[]">

<p>So I’ve copied this code from somewhere, really cant recall where:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">// assumes r, g, b are in [0 .. 1.0] range</span>
<span class="keyword">void</span> RGB2HSV(<span class="keyword">float</span> r, <span class="keyword">float</span> g, <span class="keyword">float</span> b, <span class="keyword">float</span> &h, <span class="keyword">float</span> &s, <span class="keyword">float</span> &v) {
  <span class="keyword">float</span> K = <span class="number">0.f</span>;

  <span class="keyword">if</span> (g &lt; b) {
    <span class="built_in">std</span>::swap(g, b);
    K = -<span class="number">1.f</span>;
  }

  <span class="keyword">if</span> (r &lt; g) {
    <span class="built_in">std</span>::swap(r, g);
    K = -<span class="number">2.f</span> / <span class="number">6.f</span> - K;
  }

  <span class="keyword">float</span> chroma = r - <span class="built_in">std</span>::min(g, b);
  h = <span class="built_in">fabs</span>(K + (g - b) / (<span class="number">6.f</span> * chroma + <span class="number">1e-20</span>f));
  s = chroma / (r + <span class="number">1e-20</span>f);
  v = r;
}
</pre></td></tr></table></figure>

<p>which is simply direct translation of wikipedia formulas I believe.</p>
<p>Now I will SUM all the <strong>R</strong>, <strong>G</strong> and <strong>B</strong> values and get the average. Now with given average pixel<br>of the image I can convert it to HSV and check for <strong>V(light intensity)</strong> value.</p>
<p>If you want to see HSV in effect, you can open any image editing software(Photoshop) or just click <a href="https://www.shadertoy.com/view/Xlf3zs" target="_blank" rel="external">this Shadertoy url</a>. It’s a Shadertoy demo I made. Bottom left quad is the normal view. Top left is <strong>H</strong>ue, bottom right is for <strong>S</strong>aturation and top right is for <strong>L</strong>ighting. Each value is multiplied by a different coefficient and time so you can see them in effect out of sync(imho better).</p>
<p>So as we have our average pixel, just convert it to HSV. Now take the <strong>V</strong> value and compare it against some threshold. Voila. This is some cheap and dirty detection.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre><span class="keyword">int</span> main() {
  <span class="keyword">auto</span> rSum = <span class="number">0.0</span>;
  <span class="keyword">auto</span> gSum = <span class="number">0.0</span>;
  <span class="keyword">auto</span> bSum = <span class="number">0.0</span>;

  <span class="keyword">auto</span> size = <span class="number">0</span>;

  <span class="built_in">std</span>::<span class="built_in">string</span> entry;
  <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; entry) {
    <span class="built_in">std</span>::replace(entry.begin(), entry.end(), <span class="string">','</span>, <span class="string">' '</span>);
    <span class="built_in">std</span>::<span class="built_in">stringstream</span> input(entry);

    <span class="keyword">int</span> r, g, b;

    input &gt;&gt; r;
    input &gt;&gt; g;
    input &gt;&gt; b;

    rSum += r;
    gSum += g;
    bSum += b;
    size++;
  }

  <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;

  <span class="keyword">auto</span> rAvg = rSum / size;
  <span class="keyword">auto</span> gAvg = gSum / size;
  <span class="keyword">auto</span> bAvg = bSum / size;
  
  rAvg /= <span class="number">255.0</span>;
  gAvg /= <span class="number">255.0</span>;
  bAvg /= <span class="number">255.0</span>;

  <span class="keyword">auto</span> threshold = <span class="number">0.7</span>;

  <span class="keyword">float</span> h, s, v;
  RGB2HSV(rAvg, gAvg, bAvg, h, s, v);

  <span class="keyword">if</span> (v &lt; threshold) {
    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"night"</span> &lt;&lt; <span class="built_in">std</span>::endl;
  }
  <span class="keyword">else</span> {
    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"day"</span> &lt;&lt; <span class="built_in">std</span>::endl;
  }

  <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>Again. Dont copy paste this code if you don’t get it.</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:www.letsdive.in">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/./SICP/">SICP</a><small>2</small></li>
  
    <li><a href="/./Scheme/">Scheme</a><small>2</small></li>
  
    <li><a href="/./backtracking/">backtracking</a><small>1</small></li>
  
    <li><a href="/./bower/">bower</a><small>1</small></li>
  
    <li><a href="/./brainfuck/">brainfuck</a><small>1</small></li>
  
    <li><a href="/./c/">c</a><small>2</small></li>
  
    <li><a href="/./c++/">c++</a><small>3</small></li>
  
    <li><a href="/./csp/">csp</a><small>1</small></li>
  
    <li><a href="/./editor/">editor</a><small>5</small></li>
  
    <li><a href="/./emacs/">emacs</a><small>5</small></li>
  
    <li><a href="/./functional-programming/">functional programming</a><small>2</small></li>
  
    <li><a href="/./glsl/">glsl</a><small>5</small></li>
  
    <li><a href="/./graphics/">graphics</a><small>5</small></li>
  
    <li><a href="/./grunt/">grunt</a><small>1</small></li>
  
    <li><a href="/./javascript/">javascript</a><small>14</small></li>
  
    <li><a href="/./productivity/">productivity</a><small>5</small></li>
  
    <li><a href="/./project-euler/">project euler</a><small>5</small></li>
  
    <li><a href="/./style/">style</a><small>1</small></li>
  
    <li><a href="/./sudoku/">sudoku</a><small>1</small></li>
  
    <li><a href="/./voronoi/">voronoi</a><small>1</small></li>
  
    <li><a href="/./workflow/">workflow</a><small>1</small></li>
  
    <li><a href="/./yeoman/">yeoman</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 Lukas Pukenis
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'letsdive';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-44498783-1', 'letsdive.in');
  ga('send', 'pageview');
</script>
</body>
</html>